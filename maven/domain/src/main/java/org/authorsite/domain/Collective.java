/**
 * This file is part of the authorsite application.
 *
 * The authorsite application is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * The authorsite application is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the authorsite application; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * 
 */
package org.authorsite.domain;

import javax.persistence.Entity;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;

import org.apache.commons.lang.builder.CompareToBuilder;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;

/**
 * Class representing any grouping of human beings, derived from
 * {@link AbstractHuman}. The class defines the additional property
 * <code>Place</code> to indicate where the collective is or was 
 * located. This is of primary use when indicating where, say, a 
 * publishing house is located.
 * 
 * <p>The property is a simple string and may hold more than 
 * one place term separated by commas. The property should use
 * the local term for the place at the time - e.g. MÃ¼nchen for Munich and 
 * Roma for Rome. When a place has more than one local name, such
 * as in bilingual localities, it is up to the user to pick
 * the one which seems most appropriate!</p>
 * 
 * @author jejking
 *
 */
@Entity()
@NamedQueries( {
	@NamedQuery(name = "CollectiveCount", query = "select count(c) from Collective c"),
	@NamedQuery(name = "CollectivesByName", query = "select c from Collective c where c.name = :collectiveName"),
	@NamedQuery(name = "CollectivesByNameWildcard", query = "select c from Collective c where c.name like :collectiveName"),
	@NamedQuery(name = "CollectivesByPlace", query = "select c from Collective c where c.place = :placeName"),
	@NamedQuery(name = "CollectivesByPlaceWildcard", query = "select c from Collective c where c.place like :placeName") })
public class Collective extends AbstractHuman implements
	Comparable<AbstractHuman> {

    /**
     * Generated by eclipse. 
     */
    private static final long serialVersionUID = -2520506274072773568L;

    private String place;

    /**
     * Default constructor.
     */
    public Collective() {
	super();
    }

    /**
     * Constructs collective with the given name.
     *
     * @param name name of the collective
     */
    public Collective(String name) {
	super(name);
    }

    /**
     * Constructs collective with the supplied
     * name and place parameters.
     *
     *
     * @param name
     * @param place
     */
    public Collective(String name, String place) {
	this(name);
	this.setPlace(place);
    }

    /**
     * Constructs collective with the supplied name,
     * name qualification and place parameters.
     *
     * @param name
     * @param nameQualification
     * @param place
     */
    public Collective(String name, String nameQualification, String place) {
	this(name);
	this.setNameQualification(nameQualification);
	this.setPlace(place);
    }

    /**
     * Gets place name.
     * 
     * @return place. May be <code>null</code>.
     */
    public String getPlace() {
	return this.place;
    }

    /**
     * Sets place name.
     * 
     * @param place may be <code>null</code>.
     */
    public void setPlace(String place) {
	this.place = place;
    }

    @Override
    public boolean equals(Object obj) {
	if (obj == null) {
	    return false;
	}
	if (obj == this) {
	    return true;
	}
	if (obj instanceof Collective) {
	    Collective rhs = (Collective) obj;
	    return new EqualsBuilder().append(this.getName(), rhs.getName())
		    .append(this.getPlace(), rhs.getPlace()).append(
			    this.getNameQualification(),
			    rhs.getNameQualification()).isEquals();
	} else {
	    return false;
	}
    }

    @Override
    public int hashCode() {
	return new HashCodeBuilder().append(this.getName()).append(this.place)
		.append(this.getNameQualification()).toHashCode();
    }
    
    

    @Override
    public String toString() {
	StringBuilder sb = new StringBuilder();
	sb.append(this.getName());
	if (this.place != null) {
	    sb.append(", ");
	    sb.append(this.place);
	}
	if (this.getNameQualification() != null) {
	    sb.append(" (");
	    sb.append(this.getNameQualification());
	    sb.append(")");
	}
	return sb.toString();
    }

    public int compareTo(AbstractHuman abstractHuman) {
	if (abstractHuman instanceof AbstractHuman && abstractHuman instanceof Individual) {
	    return -1;
	}
	Collective rhs = (Collective) abstractHuman;
	return new CompareToBuilder()
		.append(this.getName(), rhs.getName())
		.append(this.getPlace(), rhs.getPlace())
		.append(this.getNameQualification(), rhs.getNameQualification())
		.toComparison();
    }

}
