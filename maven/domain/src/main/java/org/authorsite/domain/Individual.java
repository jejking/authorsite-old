/**
 * This file is part of the authorsite application.
 *
 * The authorsite application is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * The authorsite application is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the authorsite application; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * 
 */

package org.authorsite.domain;

import javax.persistence.Entity;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToOne;
import javax.persistence.Transient;

import org.apache.commons.lang.builder.CompareToBuilder;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.authorsite.security.SystemUser;

/**
 * Class representing an individual human being, derived from
 * {@link AbstractHuman}. The class defines the additional property
 * <code>GivenNames</code> for first names.
 * 
 * <p>
 * The class is relatively simplistic in its modelling - it does not take
 * account of the fact that names may change over the course of someone's life.
 * A further limitation is that it does not capture birth or death events.
 * </p>.
 * 
 * @author jejking
 * 
 */
@Entity()
@NamedQueries( {
	@NamedQuery(name = "IndividualCount", query = "select count(i) from Individual i"),
	@NamedQuery(name = "IndividualsByName", query = "select i from Individual i where i.name = :individualName"),
	@NamedQuery(name = "IndividualsByNameWildcard", query = "select i from Individual i where i.name like :individualName"),
	@NamedQuery(name = "IndividualsByNameAndGivenNames", query = "select i from Individual i where i.name = :individualName and i.givenNames = :givenNames"),
	@NamedQuery(name = "IndividualsByNameAndGivenNamesWildcard", query = "select i from Individual i where i.name like :individualName and i.givenNames like :givenNames"),
        @NamedQuery(name = "AllIndividuals", query = "select i from Individual i order by id asc") })
public class Individual extends AbstractHuman implements
	Comparable<AbstractHuman> {

    /**
         * Generated by eclipse.
         */
    private static final long serialVersionUID = 2627356549862464538L;

    private String givenNames;

    // the individual may be a user, in which case this value is not null
    private SystemUser systemUser;

    /**
         * Default constructor.
         */
    public Individual() {
	super();
    }

    /**
         * Constructs individual with the given parameters.
         * 
         * @param name
         * @param givenNames
         */
    public Individual(String name, String givenNames) {
	super(name);
	setGivenNames(givenNames);
    }

    /**
         * Gets given names property.
         * 
         * @return given names. May be <code>null</code>.
         */
    public String getGivenNames() {
	return this.givenNames;
    }

    /**
         * Sets given names property.
         * 
         * @param givenNames
         *                may be <code>null</code>.
         */
    public void setGivenNames(String givenNames) {
	this.givenNames = givenNames;
    }

    /**
         * Gets the user.
         * 
         * 
         * @return user object if individual is a user who can login onto the
         *         system, else <code>null</code>
         */
    @OneToOne(mappedBy = "individual")
    public SystemUser getSystemUser() {
	return this.systemUser;
    }

    /**
         * Sets the system user property.
         * 
         * @param systemUser
         *                the user entity
         */
    protected void setSystemUser(SystemUser systemUser) {
	this.systemUser = systemUser;
    }

    /**
         * @return whether the individual is also a system user.
         */
    @Transient
    public boolean isSystemUser() {
	if (this.systemUser == null) {
	    return false;
	} else {
	    return true;
	}
    }

    @Override
    public boolean equals(Object obj) {
	if (obj == null) {
	    return false;
	}
	if (obj == this) {
	    return true;
	}
	if (obj instanceof Individual) {
	    Individual rhs = (Individual) obj;
	    return new EqualsBuilder().append(this.getName(), rhs.getName())
		    .append(this.givenNames, rhs.givenNames).append(
			    this.getNameQualification(),
			    rhs.getNameQualification()).isEquals();
	} else {
	    return false;
	}

    }

    @Override
    public int hashCode() {
	return new HashCodeBuilder().append(this.getName()).append(
		this.givenNames).append(this.getNameQualification())
		.toHashCode();
    }

    @Override
    public String toString() {
	StringBuilder sb = new StringBuilder();
	sb.append(this.getName());
	if (this.givenNames != null) {
	    sb.append(", ");
	    sb.append(this.givenNames);
	}
	if (this.getNameQualification() != null) {
	    sb.append(": ");
	    sb.append(this.getNameQualification());
	}
	return sb.toString();
    }

    public int compareTo(AbstractHuman o) {
	if (o instanceof AbstractHuman && o instanceof Collective) {
	    return 1;
	}
	Individual rhs = (Individual) o;
	return new CompareToBuilder()
		.append(this.getName(), rhs.getName())
		.append(this.givenNames, rhs.givenNames)
		.append(this.getNameQualification(), rhs.getNameQualification())
		.toComparison();

    }

}
